#lang scheme

(define (f G)
  (define n (length G))
  (define (BFS v G)
    (define (iter visited qnow queue e)
      ; (display visited) (display " ") (display queue) (display " ") (displayln e)
      (if (and (empty-queue? queue) (empty-queue? qnow) ) e
          (if (empty-queue? qnow) (iter visited queue (cons null null) (+ e 1) )
              (let* ((pos (front-queue qnow)) 
                     (next (filter (λ(x) (not (element-of-set? x visited) ) )
                                   (list-ref G pos))))
                ;(displayln next)
                (if (empty? next) (iter visited (delete-queue qnow) queue e)
                    (iter (union-set visited (sort next <) ) (delete-queue qnow)
                          (insert-list-queue queue next) e))))) )
    (iter (list v) (cons null (list v)) (cons null null) 0) )
 (define (g list-e i min li)
   (if (= i n) li
       (if (< (car list-e) min)
           (g (cdr list-e) (+ i 1) (car list-e) (list i))
       (if (= (car list-e) min)
           (g (cdr list-e) (+ i 1) min (cons i li) )
           (g (cdr list-e) (+ i 1) min li) ) ) ) )
  (define list-e (map (λ(i)(BFS i G) ) (build-list n  +) ) )
  ;(displayln list-e)
  (g (cdr list-e) 1 (car list-e) (list (car list-e) ) ) )

  (define (empty-queue? q) (and (empty? (car q)) (empty? (cdr q))))
  (define (insert-queue q x)
    (cons (car q) (cons x (cdr q))))
  (define (insert-list-queue queue lst)
    (foldl (λ(x q)(insert-queue q x) ) queue lst) )
  (define (delete-queue q)
    (if (empty? (car q))
        (cons (cdr (reverse (cdr q))) '())
        (cons (cdar q) (cdr q))))
  (define (front-queue q)
    (if (empty-queue? q)
        (error "FRONT вызвана с пустой очередью" q)
        (if (empty? (car q))
            (car (reverse (cdr q)))
            (caar q))))
  (define (element-of-set? x set)
    (cond  ((null? set) false)
           ((= x (car set)) true)
           ((< x (car set)) false)
           (else (element-of-set? x (cdr set)))))
  (define (adjoin-set x set)
    (cond ((element-of-set? x set) set)
          ((empty? set) (list x) )
          ((< x (car set) ) (cons x set) )
          (else (cons (car set) (adjoin-set x (cdr set) ) ) ) ) )
  (define (union-set set1 set2)
    (if (empty? set1) set2
        (if (empty? set2) set1
            (let ((x1 (car set1) ) (x2 (car set2)) )
              (cond ((equal? x1 x2) (cons x1 (union-set (cdr set1) (cdr set2) ) ) )
                    ((< x1 x2) (cons x1 (union-set (cdr set1) set2) ) )
                    ((< x2 x1) (cons x2 (union-set set1 (cdr set2) ) ) ) ) ) ) ) )