#lang scheme

(define // quotient)
(define % remainder)
(define (<numeral? n)
  (if (< n 10) #t
      (and (>= (% n 10) (% (// n 10) 10) ) (<numeral? (// n 10) ) ) ) )

(define (f file-in file-out )
  (define in (open-input-file file-in))
  (define out (open-output-file file-out #:exists 'replace))
  (define (line) (display #\return out) (display #\newline out) )
  (define (next s x lx a)
    (define c (read-char in))
    (if (equal? c eof)
         (let ((sum (+ x (string->number (list->string (reverse lx) ) ) ) ) )
                     (if (<numeral? sum) (cons sum a) a ) )
        (if (equal? c #\uFEFF)
            (next 0 x lx a)
        (cond ((= s 0) (if (and (char<=? #\0 c) (char>=? #\9 c) )
                           (next 0 (cons c x) lx a)
                           (next 1 (string->number (list->string (reverse x) ) ) lx a) ) )
        ((= s 1) (if (equal? c #\return)
                     (let ((sum (+ x (string->number (list->string (reverse lx) ) ) ) )
                           (e (read-char in) ) )
                     (if (<numeral? sum)
                         (next 0 null null (cons sum a) )
                         (next 0 null null a) ) )
                      (next 1 x (cons c lx) a) ) ) ) ) ) )
(define lst (sort (next 0 null null null) >) )
(define (printlst lst)
  (if (empty? lst)
      (close-output-port out)
      (begin (print (car lst) out) (line) (printlst (cdr lst) ) ) ) )
(printlst lst) )