#lang scheme
(define left cadr)
(define right caddr)
(define (data tree)
  (if (empty? tree) #f (car tree) ) )
(define empty-tree? empty?)
(define (leaf? tree) (and (empty? (left tree) ) (empty? (right tree) ) ) )

(define (f tab)
  (define (g tree)
    (if (empty? tree) #f
        (if (leaf? tree) #f
            (let ((l (g (left tree) ) ) (r (g (right tree) ) ) )
            (if (data tree)
                (if (equal? 'up (data tree) )
                    (if (empty? (left tree) )
                        (g (right tree) )
                        (g (left tree) ) )
                    (if (empty? (left tree) )
                        (if (leaf? (right tree) ) (data (right tree) ) r)
                        (if (leaf? (left tree) )  (data (left tree) ) l) ) )
                (if l l (if r r #f) ) ) ) ) ) )
  (g (tab->tree2 tab) ) )

(define (tab->tree2 tab)
  (define (left tree)
  (if (empty? tree) null (cadr tree) ) )
(define (right tree)
  (if (empty? tree) null (caddr tree) ) )
  (define (g x t tree)
    (if (equal? (data tree) 'up)
        (if (= 1 (car x) )
            (let ((r (g x t (right tree) ) ))
              (if r (list 'up (left tree) r ) #f ) )
            (let ((l (g x t (left tree) ) ) )
              (if l (list 'up l (right tree) ) #f ) ) )
        (if (and (empty? (left tree) ) (empty? (right tree) ) (not (empty? tree) ) ) #f
            (if (empty? (cdr x) ) (list t null null)
                (if (= 1 (cadr x) )
                    (let ((r (g (cdr x) t (right tree) ) ))
                      (if r (list (if (empty? tree) #t #f) (left tree) r ) #f ) )
                    (let ((l (g (cdr x) t (left tree) ) ) )
                      (if l (list (if (empty? tree) #t #f) l (right tree) ) #f ) ) ) ) ) ) )
  (define prx (foldl (λ(x tree)(if tree (g (cdr x) (car x) tree) #f) ) (list 'up null null) tab ) )
  (if (f1 tab) (if (or (empty? (left prx) ) (empty? (right prx) ) )
                   (list 'up (left prx) (right prx) )
                   (list #f (left prx) (right prx) ) )
      (let ((sfx (foldl (λ(x tree)(if tree (g (cdr x) (car x) tree) #f) ) (list 'up null null) (map (λ(x)(cons (car x) (reverse (cdr x) ) ) ) tab) ) ) )
        (if (or (empty? (left sfx) ) (empty? (right sfx) ) )
            (list 'up (left sfx) (right sfx) )
            (list #f (left sfx) (right sfx) ) ) ) ) )

(define (tab->tree tab)
 (define (left tree)
  (if (empty? tree) null (cadr tree) ) )
(define (right tree)
  (if (empty? tree) null (caddr tree) ) )
  (define (g x t tree)
    (let ((l (g (cdr x) t (left tree) ) ) (r (g (cdr x) t (right tree) ) ) )
    (if (equal? (data tree) 'up)
        (if (= 1 (car x) )
            (list 'up (left tree) r )
            (list 'up l (right tree) ) )
        (if (empty? (cdr x) ) (list t null null)
                (if (= 1 (cadr x) )
                    (list (if (empty? tree) #t #f) (left tree) r )
                    (list (if (empty? tree) #t #f) l (right tree) ) ) ) ) ) )
  (define prx (foldl (λ(x tree)(if tree (g (cdr x) (car x) tree) #f) ) (list 'up null null) tab ) )
  (if (f1 tab) (if (or (empty? (left prx) ) (empty? (right prx) ) )
                   (list #t (left prx) (right prx) )
                   (list #f (left prx) (right prx) ) )
      (let ((sfx (foldl (λ(x tree)(if tree (g (cdr x) (car x) tree) #f) ) (list 'up null null) (map (λ(x)(cons (car x) (reverse (cdr x) ) ) ) tab) ) ) )
        (if (or (empty? (left sfx) ) (empty? (right sfx) ) )
            (list #t (left sfx) (right sfx) )
            (list #f (left sfx) (right sfx) ) ) ) ) )
(define (f1 tab)
  (define (g tab)
    (if (empty? (cdr tab) ) #t
        (if (string-prefix? (cadr tab) (car tab) ) #f (g (cdr tab) ) ) ) )
  (g (sort (map (λ(x)(list->string (map (λ(t)(integer->char (+ t 48) ) ) (cdr x) ) ) ) tab) string<?) ) )
