#lang scheme
(define (left tree)
  (if (empty? tree) null (cadr tree) ) )
(define (right tree)
  (if (empty? tree) null (caddr tree) ) )
(define (data tree)
  (if (empty? tree) #f (car tree) ) )
(define empty-tree? empty?)

(define (f tab)
  (define (g tree)
    (if (empty-tree? tree)
        (cons 0 null)
        (if (and (empty-tree? (left  tree) )
                 (empty-tree? (right tree) ) )
            (cons 0 #f) 
            (let ((l (g (left tree) ) )(r (g (right tree) ) ) )
              (if (and (cdr l) (cdr r) )
                (if (empty-tree? (left tree) )
                    (cons (+ 1 (car l) ) (cons (data tree) (cons 0 (cdr l) ) ) )
                    (if (empty-tree? (right tree) )
                         (cons (+ 1 (car r) ) (cons (data tree) (cons 1 (cdr r) ) ) )
                         (if (> (car l) (car r) )
                            (cons (+ 1 (car r) ) (cons (data tree) (cdr r) ) )
                            (cons (+ 1 (car l) ) (cons (data tree) (cdr l) ) ) ) ) )
                  (if (cdr l)
                      (if (empty-tree? (left tree) )
                          (cons (+ 1 (car l) ) (cons (data tree) (cons 0 (cdr l) ) ) )
                          (cons (+ 1 (car l) ) (cons (data tree) (cdr l) ) ) )
                      (if (cdr r)
                          (if (empty-tree? (right tree) )
                              (cons (+ 1 (car r) ) (cons (data tree) (cons 1 (cdr r) ) ) )
                              (cons (+ 1 (car l) ) (cons (data tree) (cdr r) ) ) )
                          (cons 0 #f) ) ) ) ) ) ) )
  (define x (g (tab->tree tab ) ) )
  (if (cdr x) (cddr x) #f) )

(define (tab->tree2 tab)
  (define (g x t tree)
    (if (and (empty? (left tree) ) (empty? (right tree) ) (not (empty? tree) ) ) #f
            (if (empty? x) (list (car t) null null)
                (if (= 1 (car x) )
                    (let ((r (g (cdr x) (cdr t) (right tree) ) ))
                      (if r (list (car t) (left tree) r ) #f ) )
                    (let ((l (g (cdr x) (cdr t) (left tree) ) ) )
                      (if l (list (car t) l (right tree) ) #f ) ) ) ) ) )
  (define prx (foldl (λ(x tree)(if tree (g x (cons 'up x) tree) #f) ) null (map cdr tab) ) )
  (if (f1 tab) prx
      (foldl (λ(x tree)(if tree (g x (cons 'up x) tree) #f) ) null (map (λ(x)(reverse (cdr x) ) ) tab) ) ) )



(define (tab->tree tab)
  (define (tree+el t tree)
    (define (g x tree)
      (if (equal? (data tree) 'up)
          (if (= 1 (car x) )
              (list 'up (left tree) (g x (right tree) ) )
              (list 'up (g x (left tree) ) (right tree) ) )
          (if (empty? (cdr x) )
              (list (car x) null null)
              (if (= 1 (cadr x))
                  (list (car x) (left tree) (g (cdr x) (right tree ) ) )
                  (list (car x) (g (cdr x) (left tree) ) (right tree) ) ) ) ) )
    (g t tree) )
  (if (f1 tab) (foldl tree+el (list 'up null null) (map cdr tab) )
      (foldl tree+el (list 'up null null) (map reverse (map cdr tab) ) ) ) )

(define (f1 tab)
  (define (g tab)
    (if (empty? (cdr tab) ) #t
        (if (string-prefix? (cadr tab) (car tab) ) #f (g (cdr tab) ) ) ) )
 (g (sort (map (λ(x)(list->string (map (λ(t)(integer->char (+ t 48) ) ) (cdr x) ) ) ) tab) string<?) ) )

;(define (tab->tree2 tab)
;  (define (g x tree)
;    (if (equal? (data tree) 'up)
;        (if (= 1 (car x) )
;            (let ((r (g x (right tree) ) ))
;              (if r (list 'up (left tree) r ) #f ) )
;            (let ((l (g x (left tree) ) ) )
;              (if l (list 'up l (right tree) ) #f ) ) )
;        (if (and (empty? (left tree) ) (empty? (right tree) ) (not (empty? tree) ) ) #f
;            (if (empty? (cdr x) ) (list (car x) null null)
;                (if (= 1 (cadr x) )
;                    (let ((r (g (cdr x) (right tree) ) ))
;                      (if r (list (car x) (left tree) r ) #f ) )
;                    (let ((l (g (cdr x) (left tree) ) ) )
;                      (if l (list (car x) l (right tree) ) #f ) ) ) ) ) ) )
;  (define prx (foldl (λ(x tree)(if tree (g x tree) #f) ) (list 'up null null) (map cdr tab) ) )
;  (if prx prx
;      (foldl (λ(x tree)(if tree (g x tree) #f) ) (list 'up null null) (map (λ(x)(reverse (cdr x) ) ) tab) ) ) )