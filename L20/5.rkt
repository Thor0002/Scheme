#lang scheme

(define (f input output)
  (define out (open-output-file output #:exists 'replace))
  (define n+list_adj (read-list-adj input) )
  (printlist (list_adj->M (car n+list_adj) (cdr n+list_adj) ) out)
  (close-output-port out) )

(define (list_adj->M n lst_adj)
(define (change lst n-1)
    (define (g lst j k)
      (if (empty? lst) (if (<= j n-1)
                           (cons k (g lst (+ j 1) 0) )
                           null)   
          (if (= j (car lst) )
              (g (cdr lst) j (+ k 1) )
              (cons k (g lst (+ j 1) 0) ) ) ) )
    (g lst 0 0) )
(map (λ(lst)(change lst (- n 1) ) ) lst_adj ) )

(define (read-list-adj input)
  (define in (open-input-file input))
  (read-char in)
  (define (read-vertex)
    (define k (read in))
    (foldl (λ(i lst)
             (if (= i k) lst (cons (read in) lst)))
           null (build-list k values)))
  (define n (read in))
  (cons n (reverse
   (foldl (λ(i lst)
            (if (= i n) lst (cons (sort (read-vertex) <) lst)))
          null (build-list n values)))) )

(define (printlist lst out)
  (define (printlist1 lst out)
    (if (empty? lst) (display "")
        (begin (display (car lst) out) (display #\space out) (printlist1 (cdr lst) out) ) ) )
  (if (empty? (cdr lst) )
      (begin (printlist1 (car lst) out) (display #\return out) (display #\newline out) )
      (begin (printlist1 (car lst) out) (display #\return out) (display #\newline out) (printlist (cdr lst) out) ) ) )